<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>BLStream Fingerprint</title>
<date>2015-02-18</date>
</info>
<chapter xml:id="preface">
<title>Preface</title>
<simpara>BLStream Finger print is a set of practices applied in the company.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</chapter>
<chapter xml:id="project-management">
<title>Project management</title>
<section xml:id="definition-of-done">
<title>Definition of Done</title>

</section>
<section xml:id="daily-standup">
<title>Daily Standup</title>

</section>
<section xml:id="demo">
<title>Demo</title>

</section>
<section xml:id="scrum-kanban-board">
<title>Scrum/Kanban Board</title>

</section>
<section xml:id="planning-meeting">
<title>Planning Meeting</title>

</section>
<section xml:id="retrospectives">
<title>Retrospectives</title>

</section>
<section xml:id="retrospectives-shared-with-the-customer">
<title>Retrospectives shared with the customer</title>

</section>
<section xml:id="project-practices-charter-shared-with-the-customer">
<title>Project Practices Charter shared with the customer</title>

</section>
<section xml:id="collocated-team-all-team-members-pm-included">
<title>Collocated Team (all team members PM included)</title>

</section>
<section xml:id="3rd-party-libraries-licences-listed-approved">
<title>3rd party libraries licences listed, approved</title>

</section>
<section xml:id="clean-backlog">
<title>Clean Backlog</title>

</section>
<section xml:id="responsive-product-owner">
<title>Responsive Product Owner</title>

</section>
<section xml:id="grooming">
<title>Grooming</title>

</section>
<section xml:id="burnup-burndown-chart">
<title>BurnUp / BurnDown chart</title>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</chapter>
<chapter xml:id="development">
<title>Development</title>
<section xml:id="easy-infrastructure-setup">
<title>Easy infrastructure setup</title>
<simpara>from nothing to running in &lt;1h</simpara>
</section>
<section xml:id="easy-application-setup">
<title>Easy application setup</title>
<simpara>from nothing to running in &lt;1h</simpara>
</section>
<section xml:id="concurrency-in-application-code-accounted-for">
<title>Concurrency in application code accounted for</title>

</section>
<section xml:id="gui-style-guide-defined">
<title>GUI Style Guide defined</title>

</section>
<section xml:id="application-monitoring">
<title>Application Monitoring</title>

</section>
<section xml:id="unit-tests">
<title>Unit Tests</title>
<section xml:id="introduction">
<title>Introduction</title>
<simpara>Unit testing is at the core of engineering practices in BLStream. It&#8217;s not just a practice, it is a foundation on which many other, more sophisticated practices are built. Without unit tests it would be impossible to apply techniques like <xref linkend="continuous-delivery"/> or <xref linkend="test-driven-development"/> and it would make <link xlink:href="http://en.wikipedia.org/wiki/Code_refactoring">code refactorings</link> and generally code maintenance much harder and error prone.</simpara>
</section>
<section xml:id="what-do-we-understand-by-unit-tests">
<title>What do we understand by unit tests?</title>
<simpara>There are many definitions of "unit test" in the industry, see e.g. <link xlink:href="http://martinfowler.com/bliki/UnitTest.html">Martin Fowler - UnitTest</link>, which makes the term rather confusing. What we understand by unit test is simply:</simpara>
<itemizedlist>
<listitem>
<simpara>they are written by programmers themselves</simpara>
</listitem>
<listitem>
<simpara>they run fast, in seconds rather than minutes</simpara>
</listitem>
<listitem>
<simpara>they are fine-grained, each test verifies single "thing" (in other words - there is one reason to fail).</simpara>
</listitem>
</itemizedlist>
<simpara>Implementation details of how we write unit tests vary, depending on the tools and technologies the project is using. Nevertheless, common goal is to end up with a system that has complete suite of tests which "cover" all functionalities of the system. Thanks to that we are able to clean the code and to improve it anytime, not worrying that we accidentally break something. After each change we can run our tests and make sure that all works as expected. That&#8217;s really powerful. It leads to higher quality of the code, fewer bugs, faster development, happier programmers and - at the end - more satisfied customers.</simpara>
<simpara>It also means that tests are not something additional, optional. They are required and are a very important part of the system.</simpara>
</section>
<section xml:id="testability">
<title>Testability</title>
<simpara>Writing tests might be a challenge, especially for old, legacy code where no tests were so far developed. Therefore when we start to develop a system, we pay a lot of attention from the very beginning to write testable code. Rules for writing testable code are described in many places, e.g. <link xlink:href="http://misko.hevery.com/attachments/Guide-Writing%20Testable%20Code.pdf">Guide to testable code by Misko Hevery</link>, but details depend on project technologies, programming language paradigms, etc. As a general rule, we try to think about tests while writing production code or even to write tests before we implement a new feature. Strictly following that practice is called TDD and is described in chapter <xref linkend="test-driven-development"/>. That would automatically ensure testability.</simpara>
<simpara>Even in legacy code without tests, we try to write tests firstly before we make any changes. Thanks to that we can be sure that we didn&#8217;t break anything accidentally.</simpara>
</section>
<section xml:id="how-we-are-doing-unit-testing">
<title>How we are doing unit testing?</title>
<simpara>The approach we take for writing tests is to treat tests as executable specification. It simply means that tests describe desired functionality. Each test verifies one, single behavior of the system. Since tests focus on behavior they are not bound to implementation details. They verify public API of a "unit", ignoring private (hidden) methods and internal implementation structure.</simpara>
<simpara>Let&#8217;s see an example. If we need to write a function that returns filtered and sorted list of items, in a test we try to verify desired behavior only by public API, ignoring the fact that filtering and sorting internally is implemented in separate functions.</simpara>
<formalpara>
<title>Unit tests</title>
<para>
<programlisting language="java" linenumbering="unnumbered">	@Test
	public void shouldFilterActiveOnly() {
		MyRepo repo = new MyRepo();

		List&lt;Item&gt; items = repo.findItems();

		assertThat(items).are(activeOnly());
	}

	@Test
	public void shouldSortList() {
		MyRepo repo = new MyRepo();

		List&lt;Item&gt; items = repo.findItems();

		assertThat(items).isSorted();
	}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example of implementation</title>
<para>
<programlisting language="java" linenumbering="unnumbered">	public class MyRepo {

		public List&lt;Item&gt; findItems() {
			List&lt;Item&gt; items = newArrayList(new Item(), new Item());
			List&lt;Item&gt; filteredItems = filter(items);
			return sort(filteredItems);
		}

		private List&lt;Item&gt; sort(List&lt;Item&gt; items) {
			List&lt;Item&gt; itemsSorted = newArrayList(items);
			itemsSorted.sort(null);
			return itemsSorted;
		}

		private List&lt;Item&gt; filter(List&lt;Item&gt; items) {

			List&lt;Item&gt; filtered = new ArrayList&lt;&gt;();

			for (Item item : items) {
				if (item.isActive()) {
					filtered.add(item);
				}
			}
			return filtered;
		}
	}</programlisting>
</para>
</formalpara>
<simpara>As we see, tests use only public method <literal>findItems</literal> to verify both filtering and sorting and are independent of implementation details, they ignore two private functions: <literal>filter</literal> and <literal>sort</literal>. What advantages it has? Well, firstly all functionalities are "covered" by the tests. Secondly we are not bound to implementation details and these details can evolve without breaking tests. For instance, in Java 8 you do filtering and sorting using new Stream API is a single chain of function calls:</simpara>
<formalpara>
<title>Implementation in Java 8</title>
<para>
<programlisting language="java" linenumbering="unnumbered">	public List&lt;Item&gt; findItems() {
		List&lt;Item&gt; items = newArrayList(new Item(), new Item());
		return items.stream()
			.filter(Item::isActive)
			.sorted()
			.collect(Collectors.toList());
	}</programlisting>
</para>
</formalpara>
<simpara>A change that is purely implementational, does not require tests to update. Tests remain stable, clean and are focused on behavior verification.</simpara>
<simpara>The tests that we presented show also basic structure of the test, which consists of 3 main steps: <emphasis>Given, When, Then</emphasis>, as on the example below:</simpara>
<formalpara>
<title>Structure of a test</title>
<para>
<programlisting language="java" linenumbering="unnumbered">	@Test
	public void shouldSortList() {
		MyRepo repo = new MyRepo(); <co xml:id="CO1-1"/>

		List&lt;Item&gt; items = repo.findItems(); <co xml:id="CO1-2"/>

		assertThat(items).isSorted(); <co xml:id="CO1-3"/>
	}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>Section <emphasis>Given</emphasis> - should set up all required objects, pre-conditions to the test</para>
</callout>
<callout arearefs="CO1-2">
<para>Section <emphasis>When</emphasis> - behavior, action you are testing</para>
</callout>
<callout arearefs="CO1-3">
<para>Section <emphasis>Then</emphasis> - verifies expected state</para>
</callout>
</calloutlist>
<simpara>Ideally, tests have only these 3 lines. Even if there is more to do in a test, it is always possible to refactor to these 3 lines.</simpara>
<simpara>We also do, from time to time, other kinds of testing which also employ unit test tools (like JUnit). These could be for instance learning tests (that verify how external library works), low level detailed tests which drive design of implementation details. Nevertheless they are not obligatory, they might be deleted when no longer needed, so all rules mentioned above do not apply here. We also sometimes employ unit testing tools for integration tests which is described in a separate article <xref linkend="integration-tests"/>.</simpara>
</section>
<section xml:id="references">
<title>References</title>
<simpara>List of online resources which go deeper into unit testing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link xlink:href="http://martinfowler.com/bliki/UnitTest.html">http://martinfowler.com/bliki/UnitTest.html</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://blog.8thlight.com/uncle-bob/2013/09/23/Test-first.html">http://blog.8thlight.com/uncle-bob/2013/09/23/Test-first.html</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://blog.8thlight.com/uncle-bob/2014/01/27/TheChickenOrTheRoad.html">http://blog.8thlight.com/uncle-bob/2014/01/27/TheChickenOrTheRoad.html</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://blog.arkency.com/2014/09/unit-tests-vs-class-tests/">http://blog.arkency.com/2014/09/unit-tests-vs-class-tests/</link></simpara>
</listitem>
</orderedlist>
<simpara>List of books:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link xlink:href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530">http://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054">http://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054</link></simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="integration-tests">
<title>Integration tests</title>

</section>
<section xml:id="scalability-requirements-known-and-accounted-for">
<title>Scalability requirements known and accounted for</title>

</section>
<section xml:id="performance-requirements-known-and-accounted-for">
<title>Performance requirements known and accounted for</title>

</section>
<section xml:id="static-code-analysis-backend">
<title>Static code analysis (backend)</title>

</section>
<section xml:id="application-events-logging">
<title>Application events logging</title>

</section>
<section xml:id="owasp-top-10-in-definition-of-done">
<title>OWASP Top 10 in Definition of Done</title>

</section>
<section xml:id="authorization-model-defined">
<title>Authorization model defined</title>

</section>
<section xml:id="continuous-integration">
<title>Continuous Integration</title>

</section>
<section xml:id="continuous-delivery">
<title>Continuous Delivery</title>

</section>
<section xml:id="continuous-deployment">
<title>Continuous Deployment</title>

</section>
<section xml:id="documentation-tracked-in-vcs">
<title>Documentation tracked in VCS</title>

</section>
<section xml:id="documentation-generated-during-ci">
<title>Documentation generated during CI</title>

</section>
<section xml:id="parts-of-the-documentation-generated-automatically">
<title>Parts of the documentation generated automatically</title>

</section>
<section xml:id="automatic-documentation-of-the-executed-tests">
<title>Automatic documentation of the executed tests</title>

</section>
<section xml:id="documentation-scope-agreed">
<title>Documentation scope agreed</title>

</section>
<section xml:id="js-application-framework">
<title>JS application framework</title>

</section>
<section xml:id="js-build-process">
<title>JS Build process</title>

</section>
<section xml:id="js-modules-dependency-management">
<title>JS modules dependency management</title>

</section>
<section xml:id="js-unit-test">
<title>JS Unit test</title>

</section>
<section xml:id="css-builder">
<title>CSS builder</title>

</section>
<section xml:id="static-code-analysis-javascript">
<title>Static code analysis (JavaScript)</title>

</section>
<section xml:id="truly-restful-interfaces">
<title>Truly RESTful interfaces</title>

</section>
<section xml:id="html-validation">
<title>HTML validation</title>

</section>
<section xml:id="code-reviews">
<title>Code Reviews</title>

</section>
<section xml:id="pair-programming">
<title>Pair Programming</title>

</section>
<section xml:id="test-driven-development">
<title>Test Driven Development</title>
<section xml:id="introduction-2">
<title>Introduction</title>

</section>
<section xml:id="when-to-apply">
<title>When to apply</title>

</section>
<section xml:id="in-practice">
<title>In practice</title>

</section>
</section>
<section xml:id="database-schema-versioning">
<title>Database schema versioning</title>

</section>
<section xml:id="database-data-versioning">
<title>Database data versioning</title>

</section>
<section xml:id="concurrency-for-db-writes">
<title>Concurrency for DB writes</title>

</section>
<section xml:id="version-control-system">
<title>Version Control System</title>

</section>
<section xml:id="branching-strategy">
<title>Branching strategy</title>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</chapter>
<chapter xml:id="quality-assurance">
<title>Quality assurance</title>
<section xml:id="radiator">
<title>Radiator</title>

</section>
<section xml:id="defect-tracking-system">
<title>Defect Tracking System</title>

</section>
<section xml:id="defined-bug-lifecycle">
<title>Defined bug lifecycle</title>

</section>
<section xml:id="at-least-1-qa-for-every-4-developers">
<title>At least 1 QA for every 4 developers</title>

</section>
<section xml:id="bug-report-template">
<title>Bug report template</title>

</section>
<section xml:id="bug-triage-meeting">
<title>Bug triage meeting</title>

</section>
<section xml:id="smoke">
<title>Smoke</title>

</section>
<section xml:id="integration">
<title>Integration</title>

</section>
<section xml:id="functional-acceptance">
<title>Functional / Acceptance</title>

</section>
<section xml:id="spelling">
<title>Spelling</title>

</section>
<section xml:id="security">
<title>Security</title>

</section>
<section xml:id="performance">
<title>Performance</title>

</section>
<section xml:id="exploratory">
<title>Exploratory</title>

</section>
<section xml:id="usability">
<title>Usability</title>

</section>
<section xml:id="versioned-repository-of-the-test-scenarios">
<title>Versioned repository of the test scenarios</title>

</section>
<section xml:id="pair-testing">
<title>Pair testing</title>

</section>
</chapter>
</book>